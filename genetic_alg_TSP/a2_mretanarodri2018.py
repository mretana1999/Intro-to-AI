# -*- coding: utf-8 -*-
"""genetic_algorithm_TSP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O0vQcSKvS7Z7286m-SXnLNkFHu7-GDvR
"""

import numpy as np, random, operator, pandas as pd, matplotlib.pyplot as plt
import time

OPTIONS_AVAILABLE_DICT = {
                            'selection':{'1':'Roulette Wheel Selection with Pandas','2':'Roulette Wheel Selection with lists','3':'Tournament Selection'},
                            'breeding':{'1':'Order Crossover', '2':'Same Value-Position Crossover', '3':'Improved Order Crossover'},
                            'mutation':{'1':'Swap Mutation', '2':'Inversion Mutation', '3':'Scramble Mutation'},
                            'stop condition':{'1':'Specified number of Generations', '2':'Stop if no improvement (Stagnation)'}
                        }

USER_SELECTED_OPTIONS_DICT = {'selection':'1', 'breeding':'1', 'mutation':'1', 'stop condition':'1'}

random.seed(10) #Set seed to keep getting consistent results

"""## Create necessary classes and functions

Create class to handle "cities"
"""

class City:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance(self, city):
        xDis = abs(self.x - city.x)
        yDis = abs(self.y - city.y)
        distance = np.sqrt((xDis ** 2) + (yDis ** 2))
        return distance
    
    def __repr__(self):
        return "(" + str(self.x) + "," + str(self.y) + ")"

"""Create a fitness function"""

class Fitness:
    def __init__(self, route):
        self.route = route
        self.distance = 0
        self.fitness= 0.0
    
    def routeDistance(self):
        if self.distance ==0:
            pathDistance = 0
            for i in range(0, len(self.route)):
                fromCity = self.route[i]
                toCity = None
                if i + 1 < len(self.route):
                    toCity = self.route[i + 1]
                else:
                    toCity = self.route[0]
                pathDistance += fromCity.distance(toCity)
            self.distance = pathDistance
        return self.distance
    
    def routeFitness(self):
        if self.fitness == 0:
            self.fitness = 1 / float(self.routeDistance())
        return self.fitness

"""## Create our initial population

Route generator
"""

def createRoute(cityList):
    route = random.sample(cityList, len(cityList))
    return route

"""Create first "population" (list of routes)"""

def initialPopulation(popSize, cityList):
    population = []

    for i in range(0, popSize):
        population.append(createRoute(cityList))
    return population

"""## Create the genetic algorithm

Rank individuals
"""

def rankRoutes(population):
    fitnessResults = {}
    for i in range(0,len(population)):
        fitnessResults[i] = Fitness(population[i]).routeFitness()
    return sorted(fitnessResults.items(), key = operator.itemgetter(1), reverse = True)

"""Create a selection function that will be used to make the list of parent routes"""

def selection(popRanked, eliteSize):
    selectionResults = []
    df = pd.DataFrame(np.array(popRanked), columns=["Index","Fitness"])
    df['cum_sum'] = df.Fitness.cumsum()
    df['cum_perc'] = 100*df.cum_sum/df.Fitness.sum()
    
    for i in range(0, eliteSize):
        selectionResults.append(popRanked[i][0])
    for i in range(0, len(popRanked) - eliteSize):
        pick = 100*random.random()
        for i in range(0, len(popRanked)):
            if pick <= df.iat[i,3]:
                selectionResults.append(popRanked[i][0])
                break
    return selectionResults

#Roulette wheel selection more similar to the one in the textbook (with elitism)
def roulette_wheel_selection(popRanked, eliteSize):
    '''Takes popRanked list of tuples of the format [(index,fitness),...] and size of elite group. Returns a list of the indices of the selected individuals'''
    selectionResults = []
    population_sum = sum(individual[1] for individual in popRanked) #sum of individual fitnesses
    popRanked_probabilities = [(individual[0], individual[1] / population_sum) for individual in popRanked] #convert popRanked into list of format [(index,probability),...]
    slices = []
    total = 0
    for i in range(eliteSize): #preserve elite individuals
        selectionResults.append(popRanked[i][0])
    for i in range(len(popRanked)):
        individual = popRanked_probabilities[i]
        slices.append([i,total, total + individual[1]]) #index 1 stores the probability of that individual
        total += individual[1]
    for i in range(len(popRanked) - eliteSize):
        spin = random.random()
        result = [s[0] for s in slices if s[1] < spin <= s[2]]
        selectionResults.append(popRanked[result[0]][0]) #store the original population index of the selected individual
    return selectionResults

#Tournament selection with elitism implementation
def tournament_selection(popRanked, eliteSize):
    tournament_size = 5
    selectionResults = []
    for i in range(eliteSize): #preserve elite individuals
        selectionResults.append(popRanked[i][0])
    for i in range(len(popRanked)-eliteSize):
        competitors = random.sample(popRanked, tournament_size) #get random sample of population of size tournament_size
        winner = max(competitors, key = lambda individual: individual[1]) #select winner out of the sample based on fitness
        selectionResults.append(winner[0])
    return selectionResults

"""Create mating pool"""

def matingPool(population, selectionResults):
    matingpool = []
    for i in range(0, len(selectionResults)):
        index = selectionResults[i]
        matingpool.append(population[index])
    return matingpool

"""Create a crossover function for two parents to create one child"""

def breed(parent1, parent2):
    child = []
    childP1 = []
    childP2 = []
    
    geneA = int(random.random() * len(parent1))
    geneB = int(random.random() * len(parent1))
    
    startGene = min(geneA, geneB)
    endGene = max(geneA, geneB)

    for i in range(startGene, endGene):
        childP1.append(parent1[i])
        
    childP2 = [item for item in parent2 if item not in childP1]

    child = childP1 + childP2
    return child

def breed_same_value(parent1, parent2):
    ind_same_value = []
    stack_diff_value = []
    child = []
    for i in range(len(parent1)):
        if parent1[i] == parent2[i]: #if parent1 and parent2 share the same gene at same position
            ind_same_value.append(i)
        else:
            stack_diff_value.append(parent1[i])
    random.shuffle(stack_diff_value)
    if not ind_same_value: #if parents do not share any genes as the same position
        return breed(parent1, parent2)
    for i in range(len(parent1)):
        if i in ind_same_value:
            child.append(parent1[i])
        else:
            child.append(stack_diff_value.pop())
    return child

def breed_ordered(parent1, parent2):
    child = []
    geneA = int(random.random() * len(parent1))
    geneB = int(random.random() * len(parent1))
    startGene = min(geneA, geneB)
    endGene = max(geneA, geneB)
    gene_range_p1 = range(startGene,endGene) #store indexes of the selected genes from parent1
    gene_range_values_p1 = parent1[startGene:endGene] #store values of selected genes from parent1
    for i in range(len(parent1)):
        if i in gene_range_p1: #if indexes of selected genes have been reached, append them in the same order as they were in parent1
            child.append(parent1[i])
        else:
            for j in range(len(parent2)):
                #if indexes of selected genes not reached, append genes from parent 2 such that duplicates are not allowed
                if parent2[j] not in gene_range_values_p1 and parent2[j] not in child:  
                    child.append(parent2[j])
                    break
    return child


"""Create function to run crossover over full mating pool"""

def breedPopulation(matingpool, eliteSize):
    children = []
    length = len(matingpool) - eliteSize
    pool = random.sample(matingpool, len(matingpool))

    for i in range(0,eliteSize):
        children.append(matingpool[i])
    
    for i in range(0, length):
        if USER_SELECTED_OPTIONS_DICT['breeding'] == '1':
            child = breed(pool[i], pool[len(matingpool)-i-1]) #swap mutation
        if USER_SELECTED_OPTIONS_DICT['breeding'] == '2':
            child = breed_same_value(pool[i], pool[len(matingpool)-i-1]) #Same-value-position crossover
        if USER_SELECTED_OPTIONS_DICT['breeding'] == '3':
            child = breed_ordered(pool[i], pool[len(matingpool)-i-1]) #Improved order crossover
        children.append(child)
    return children

"""Create function to mutate a single route"""

def mutate(individual, mutationRate):
    for swapped in range(len(individual)):
        if(random.random() < mutationRate):
            swapWith = int(random.random() * len(individual))
            
            city1 = individual[swapped]
            city2 = individual[swapWith]
            
            individual[swapped] = city2
            individual[swapWith] = city1
    return individual

def mutate_inversion(individual, mutationRate):
    if(random.random() < mutationRate):
        geneA = int(random.random() * len(individual))
        geneB = int(random.random() * len(individual))
        startGene = min(geneA, geneB)
        endGene = max(geneA, geneB)
        individual_copy = individual[:]
        individual_subset_reversed = individual_copy[startGene:endGene]
        individual_subset_reversed = individual_subset_reversed[::-1] #inverse of given subset
        individual[startGene:endGene] = individual_subset_reversed
    return individual

def mutate_scramble(individual, mutationRate):
    if(random.random() < mutationRate):
        geneA = int(random.random() * len(individual))
        geneB = int(random.random() * len(individual))
        startGene = min(geneA, geneB)
        endGene = max(geneA, geneB)
        subset = individual[startGene:endGene]
        subset_scrambled = random.sample(subset,len(subset))
        individual[startGene:endGene] = subset_scrambled
    return individual

"""Create function to run mutation over entire population"""

def mutatePopulation(population, mutationRate):
    mutatedPop = []
    
    for ind in range(0, len(population)):
        if USER_SELECTED_OPTIONS_DICT['mutation'] == '1':
            mutatedInd = mutate(population[ind], mutationRate) #swap mutation
        if USER_SELECTED_OPTIONS_DICT['mutation'] == '2':
            mutatedInd = mutate_inversion(population[ind], mutationRate) #Inversion mutation
        if USER_SELECTED_OPTIONS_DICT['mutation'] == '3':
            mutatedInd = mutate_scramble(population[ind], mutationRate) #Scramble mutation
        mutatedPop.append(mutatedInd)
    return mutatedPop

"""Put all steps together to create the next generation"""

def nextGeneration(currentGen, eliteSize, mutationRate):
    popRanked = rankRoutes(currentGen)
    if USER_SELECTED_OPTIONS_DICT['selection'] == '1':
        selectionResults = selection(popRanked, eliteSize) #Roulette with Pandas
    if USER_SELECTED_OPTIONS_DICT['selection'] == '2':
        selectionResults = roulette_wheel_selection(popRanked,eliteSize) #Roulette with lists
    if USER_SELECTED_OPTIONS_DICT['selection'] == '3':
        selectionResults = tournament_selection(popRanked, eliteSize) #Tournament selection
    matingpool = matingPool(currentGen, selectionResults)
    children = breedPopulation(matingpool, eliteSize)
    nextGeneration = mutatePopulation(children, mutationRate)
    return nextGeneration

def plot_route(route):
    x = [city.x for city in route] + [route[0].x] #list of x coordinates + salesman goes back to initial city
    y = [city.y for city in route] + [route[0].y]
    #create and show cities' positions subplots
    plt.subplot(1,2,1)
    plt.scatter(x,y, color = 'b')
    plt.ylabel('y-coordinates')
    plt.xlabel('x-coordinates')
    plt.title('Position of cities to be visited')
    #create and show current optimal route
    plt.subplot(1,2,2)
    plt.plot(x,y,color = 'r',zorder = 2) #draw connecting lines
    plt.scatter(x,y,color = 'b', zorder = 1) #draw dots
    plt.ylabel('y-coordinates')
    plt.xlabel('x-coordinates')
    plt.title('Best current solution')
    plt.show()

def plot_progress(progress):
    plt.plot(progress)
    plt.ylabel('Distance')
    plt.xlabel('Generation')
    plt.title('Best route across generations')
    plt.show()

def get_user_selection():
    for step in OPTIONS_AVAILABLE_DICT:
        print(f"Which option would you like for **{step}** ")
        for option, description in OPTIONS_AVAILABLE_DICT[step].items():
            print(f"Option {option} : {description}")
        while True:
            decision = input(f" Enter your selection for **{step}**: ")
            if decision in OPTIONS_AVAILABLE_DICT[step]:
                USER_SELECTED_OPTIONS_DICT[step] = decision
                break
            else:
                print('Invalid input, try again: ')
                continue
    print('\nYour final selection is: ')
    for step, decision_num in USER_SELECTED_OPTIONS_DICT.items():
        print(f"{step}: {decision_num} {OPTIONS_AVAILABLE_DICT[step][decision_num]}")
    print('Please wait for the program to finish running.')

def pretty_print_route(route):
    print('The optimal route found is: ')
    for city in route:
        print(f"{city} -> ", end='')
    print(route[0]) #Go back to initial city

"""Final step: create the genetic algorithm"""

def geneticAlgorithm(population, popSize, eliteSize, mutationRate, generations):
    pop = initialPopulation(popSize, population)
    print("Initial distance: " + str(1 / rankRoutes(pop)[0][1]))
    
    for i in range(0, generations):
        pop = nextGeneration(pop, eliteSize, mutationRate)
    
    print("Final distance: " + str(1 / rankRoutes(pop)[0][1]))
    bestRouteIndex = rankRoutes(pop)[0][0]
    bestRoute = pop[bestRouteIndex]
    return bestRoute

def geneticAlgorithmPlot(population, popSize, eliteSize, mutationRate, generations):
    pop = initialPopulation(popSize, population)
    print("Initial distance: " + str(1 / rankRoutes(pop)[0][1])) #
    initial_best_route_index = rankRoutes(pop)[0][0]
    initial_best_route = pop[initial_best_route_index]
    plot_route(initial_best_route)

    progress = []
    progress.append(1 / rankRoutes(pop)[0][1])
    no_improvement_count = 0
    for i in range(0, generations):
        pop = nextGeneration(pop, eliteSize, mutationRate)
        progress.append(1 / rankRoutes(pop)[0][1])
        if USER_SELECTED_OPTIONS_DICT['stop condition'] == '2':
            if progress[i+1] <= progress[i] * 1.01: #if improvement is not greater than 1%
                no_improvement_count += 1
                if no_improvement_count == 75: #if solution has not progressed for 75 consecutive generations stop
                    break
            else:
                no_improvement_count = 0 #reset counter if there has been improvement
    
    print("Final distance: " + str(1 / rankRoutes(pop)[0][1])) #
    bestRouteIndex = rankRoutes(pop)[0][0]
    bestRoute = pop[bestRouteIndex]
    plot_route(bestRoute)

    plot_progress(progress)
    return bestRoute #

"""Run the function with our assumptions to see how distance has improved in each generation"""


"""## Running the genetic algorithm Create list of cities"""
cityList = []

for i in range(0,25):
    cityList.append(City(x=int(random.random() * 200), y=int(random.random() * 200)))

"""Run the genetic algorithm"""
"""## Plot the progress"""

get_user_selection()
start_time = time.time() #measure execution time
bestRoute = geneticAlgorithmPlot(population=cityList, popSize=100, eliteSize=20, mutationRate=0.01, generations=500)
pretty_print_route(bestRoute)
end_time = time.time()
total_time = end_time - start_time
print('Total time execution time: ', total_time)